import { toWebRequest } from 'h3';// 假设这是你之前使用的 D1 绑定提取函数import { getD1Binding } from '~/server/database/database';// 假设 initializeAuth 现在是需要 D1 绑定的函数import { initializeAuth } from '~/lib/auth/auth';import {  getHeader,  readRawBody,  setResponseStatus,  setResponseHeaders,} from 'h3'export default defineEventHandler(async (event) => {  /* 1. 还原真实 URL（必须带协议 + 主机） */  const proto = getHeader(event, 'x-forwarded-proto') || 'https'  const host  = getHeader(event, 'x-forwarded-host') || getHeader(event, 'host')  const url   = `${proto}://${host}${event.node.req.url || ''}`  /* 2. 读取原始 body（不解析） */  const body = event.method !== 'GET' ? await readRawBody(event) : undefined  /* 3. 构造 Node->Web 的 Request 对象        关键点：headers 用原生 IncomingMessage，别自己拼 */  const headers = new Headers()  for (const [k, v] of Object.entries(event.node.req.headers)) {    if (v !== undefined) headers.set(k, Array.isArray(v) ? v.join(',') : v)  }  const request = new Request(url, {    method : event.method,    headers,    body,    // Node 流兼容    duplex : 'half',  } as any)  // 1. 【核心区别】: 获取 D1 绑定  let dbBinding;  try {    // 假设你的 D1 绑定名称是 'DB'    dbBinding = getD1Binding(event);  } catch (error) {    throw createError({      statusCode: 500,      statusMessage: 'D1 绑定失败' || error,    });  }  const authInstance = initializeAuth(dbBinding);  // 4. 交给 better-auth  const response = await authInstance.handler(request)  /* 5. 把响应写回 Nitro */  setResponseStatus(event, response.status)  setResponseHeaders(event, Object.fromEntries(response.headers))  return response.text()})